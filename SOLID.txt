Single-responsibility Principle
	This principle says that each class has to do only one thing. Why? Because modular is better in programming. You always encounter places in the architecture of a system where you need the same functionality and you should never implement it twice. Why? Because efficiently mantaining duplicated code is very hard and bug prone. One more plus to this S. principle is the fact that you can make better unit tests that actually test only one thing and if a test fails you know exactly what doesn't work.
Open-closed Principle
	This principle refers to the way a class should be built. A class should be OPEN to extension(not necessarily, but in most cases) in such a way that if you want to extend it you do not have to change it (it should be CLOSED for modification). If you want to implement something in a class that doesn't seem to be extendable, then, most probably, that part of code belongs to another class. This principle helps in the case when you have a class that is compiled, which you cannot modify, and you want to extend it. It also helps make your code less bug prone by trying to "close" as much as possible already written code(latter changes in a class can cause bugs in place where that class is used).
Liskov substitution principle
	Liskov principle says that if you want to extend a class you should only give it more functionality and not take any away. If you extend A with class B you have to make sure B can be used as an A in any possible case. If we think about this from the "Design by contract" point of view then this principle says that you cannot make the preconditions stricter (expecting the user to make sure more conditions are met for using B as an A than actually using an A), you cannot make the postconditions less strict (allowing B's implementation to break A's postconditions) and you have to guarantee A's invariant for B too. This also applies to the exceptions that are thrown from an overridden method. They should be the ones expected to be thrown from the original method or extensions of those.
Interface segregation principle
	From what I understand this principle is the "Single-responsability" version for interfaces. Interfaces should be made is such a way that if someone needs to make an object implement that interface, then, most probably, that someone wants that class to implement all the methods in that interface and he\she should not be forced to implement methods that he\she doesn't intend to. Basically, modular is the way.
Dependency Inversion principle
	My favorite one. This one says that a high level component should not depend on a low level one directly. It should depend on an abstraction of it, like an interface. Why? Because if you later on intend to change the low level implementation you can easily implement that interface and "dependency inject" it into the high level component and that component wont have any idea anything changed ( in terms of functionality). If we think about it this principle helps us apply the "closed" part of the "Open-closed principle" by helpin us keep the high level component "closed". You can also easily mock dependencies for testing.